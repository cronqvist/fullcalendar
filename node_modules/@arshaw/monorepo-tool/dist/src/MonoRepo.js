"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const fs = require("fs");
const path_1 = require("path");
const path_2 = require("./util/path");
const errors_1 = require("./errors");
const Pkg_1 = require("./pkg/Pkg");
const inner_pkg_query_1 = require("./pkg/inner-pkg-query");
const parse_1 = require("./pkg/parse");
const YarnNpmClient_1 = require("./npm/YarnNpmClient");
const DefactoNpmClient_1 = require("./npm/DefactoNpmClient");
const fileExists = util_1.promisify(fs.exists);
const JS_CONFIG_FILENAME = 'monorepo.config.js';
const JSON_CONFIG_FILENAME = 'monorepo.json';
class MonoRepo {
    constructor(rootDir, rootPkg, innerPkgs, npmClient, cmdConfigs) {
        this.rootDir = rootDir;
        this.rootPkg = rootPkg;
        this.innerPkgs = innerPkgs;
        this.npmClient = npmClient;
        this.cmdConfigs = cmdConfigs;
        this.innerPkgsByName = {};
        this.innerPkgsByName = Pkg_1.hashPkgsByName(innerPkgs);
    }
    getCmdNpmArgs(cmd) {
        return (this.cmdConfigs[cmd] || {}).npmClientArgs || [];
    }
}
exports.default = MonoRepo;
function queryMonoRepoWithDir(cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        let configPath = yield queryConfigPath(cwd);
        if (!configPath) {
            throw new errors_1.MissingConfigError(cwd);
        }
        let rootConfigInput = require(configPath); // for JS or JSON
        let rootConfig = parse_1.parseConfig(rootConfigInput);
        let rootDir = path_1.dirname(configPath);
        let innerPkgConfigs = parse_1.parseAllPkgInput(rootConfigInput.packages, rootConfig);
        return Promise.all([
            queryRootPkg(rootConfig, rootDir),
            inner_pkg_query_1.queryInnerPkgs(innerPkgConfigs, rootDir)
        ]).then(([rootPkg, innerPkgs]) => {
            return new MonoRepo(rootDir, rootPkg, innerPkgs, buildNpmClient(rootConfigInput.npmClient), rootConfigInput.commands || {});
        });
    });
}
exports.queryMonoRepoWithDir = queryMonoRepoWithDir;
function queryRootPkg(rootConfig, rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        let pkgJsonPath = path_1.join(rootDir, 'package.json');
        let exists = yield fileExists(pkgJsonPath);
        if (exists) {
            let pkg = new Pkg_1.default(rootDir, rootConfig.npmClientArgs || []);
            yield pkg.loadJson();
            return pkg;
        }
        else {
            return null;
        }
    });
}
function queryConfigPath(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        do {
            let jsConfigPath = path_1.join(dir, JS_CONFIG_FILENAME);
            let jsonConfigPath = path_1.join(dir, JSON_CONFIG_FILENAME);
            if (yield fileExists(jsConfigPath)) {
                return jsConfigPath;
            }
            if (yield fileExists(jsonConfigPath)) {
                return jsonConfigPath;
            }
            dir = path_1.dirname(dir);
        } while (!path_2.pathIsRoot(dir));
        return '';
    });
}
function buildNpmClient(npmClientName) {
    return npmClientName === 'yarn'
        ? new YarnNpmClient_1.default()
        : new DefactoNpmClient_1.default();
}
