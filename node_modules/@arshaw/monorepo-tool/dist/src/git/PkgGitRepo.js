"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const GitRepo_1 = require("./GitRepo");
/*
Represents a git repo that contains one or more *packages* and one or more git *submodules*.
Shouln't be instantiated directly :( Use buildPkgGitRepo instead
*/
class PkgGitRepo extends GitRepo_1.default {
    constructor() {
        super(...arguments);
        this.pkgs = [];
        this.submodules = [];
    }
    loadSubmodules() {
        return __awaiter(this, void 0, void 0, function* () {
            let submoduleDirs = yield this.getSubmoduleDirs();
            this.submodules = submoduleDirs.map((dir) => new PkgGitRepo(dir));
        });
    }
    populatePkgs(pkgsByGitDir) {
        let ownPkgs = pkgsByGitDir[this.rootDir];
        if (ownPkgs) {
            this.pkgs = ownPkgs;
        }
        for (let submodule of this.submodules) {
            submodule.populatePkgs(pkgsByGitDir);
        }
    }
}
exports.default = PkgGitRepo;
function buildPkgGitRepo(rootDir, pkgs) {
    let pkgGitRepo = new PkgGitRepo(rootDir);
    return Promise.all([
        GitRepo_1.getDirIsRepoRoot(rootDir),
        getPkgsByGitDir(pkgs),
        pkgGitRepo.loadSubmodules()
    ]).then(([isRepoRoot, pkgsByGitDir]) => {
        if (isRepoRoot) {
            pkgGitRepo.populatePkgs(pkgsByGitDir);
            return pkgGitRepo;
        }
        else {
            throw new errors_1.NoRepoRootError(rootDir);
        }
    });
}
exports.buildPkgGitRepo = buildPkgGitRepo;
/*
TODO: more consistent ordering
*/
function getPkgsByGitDir(pkgs) {
    let pkgsByGitDir = {};
    let promises = [];
    for (let pkg of pkgs) {
        promises.push(GitRepo_1.getRepoRootDir(pkg.dir).then((gitDir) => {
            ;
            (pkgsByGitDir[gitDir] || (pkgsByGitDir[gitDir] = []))
                .push(pkg);
        }));
    }
    return Promise.all(promises).then(() => pkgsByGitDir);
}
