"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const exec_1 = require("../util/exec");
const log_1 = require("../util/log");
class GitRepo {
    constructor(rootDir) {
        this.rootDir = rootDir;
    }
    /*
    Run diff interactively without buffering
    */
    runDiff(pathMatches, ignoreMatches, gitArgs = [], doPager = true) {
        return this.execLive([
            ...(doPager ? [] : ['--no-pager']),
            'diff', ...gitArgs, '--', ...buildDiffFileArgs(pathMatches, ignoreMatches)
        ]);
    }
    addFile(filePath, gitArgs = []) {
        return this.exec(['add', ...gitArgs, '--', filePath]);
    }
    resetFile(filePath, gitArgs = []) {
        return this.exec(['reset', ...gitArgs, '--', filePath]);
    }
    createTag(tagName, message, doSign, gitArgs = []) {
        return this.exec(['tag', doSign ? '-s' : '-a', tagName, '-m', message, ...gitArgs]);
    }
    commit(message, doHooks, gitArgs = []) {
        let cmd = ['commit', '-m', message];
        if (!doHooks) {
            cmd.push('--no-verify');
        }
        cmd.push(...gitArgs);
        return this.exec(cmd);
    }
    /*
    ignoreFiles is an array of strings that can have globs
    */
    hasChangesSince(sinceCommit, pathMatches = null, ignoreMatches = [], gitArgs = []) {
        let cmd = [
            'diff', sinceCommit, '--name-only', '--ignore-submodules', ...gitArgs,
            '--', ...buildDiffFileArgs(pathMatches, ignoreMatches)
        ];
        log_1.log(cmd);
        return this.exec(cmd).then((output) => {
            return Boolean(output.trim());
        });
    }
    isDirty(gitArgs = []) {
        return this.exec(['status', '--porcelain', '--untracked-files=no', ...gitArgs])
            .then((output) => Boolean(output.trim()));
    }
    /*
    help from:
    https://stackoverflow.com/a/16818141/96342
    */
    getTagUnderlyingHash(tagName) {
        return this.exec(['rev-parse', tagName + '^{}']).then((output) => {
            return output.trim();
        }, () => {
            return '';
        });
    }
    /*
    returns absolute dir paths
    */
    getSubmoduleDirs() {
        return this.exec(['submodule']).then((output) => {
            output = output.trim();
            if (!output) {
                return [];
            }
            else {
                return output.split(/[\n\r]+/g).map((line) => {
                    let parts = line.trim().split(/\s+/g);
                    let relDir = parts[1];
                    if (relDir) {
                        return path_1.join(this.rootDir, relDir);
                    }
                    else {
                        return '';
                    }
                });
            }
        });
    }
    getSubmoduleCommit(parentCommit, submoduleDir) {
        return this.exec(['ls-tree', parentCommit, '--', submoduleDir]).then((output) => {
            let parts = output.trim().split(/\s+/g);
            return parts[2] || '';
        }, () => {
            return ''; // submodule didnt exist at that point? return blank string
        });
    }
    exec(cmd) {
        return exec_1.execBuffered(['git'].concat(cmd), this.rootDir);
    }
    execLive(cmd) {
        return exec_1.execLive(['git'].concat(cmd), this.rootDir);
    }
}
exports.default = GitRepo;
/*
https://stackoverflow.com/questions/957928/is-there-a-way-to-get-the-git-root-directory-in-one-command
*/
function getRepoRootDir(currentDir) {
    return exec_1.execBuffered(['git', 'rev-parse', '--show-toplevel'], currentDir)
        .then((output) => output.trim(), () => '' // no git repo root? return blank string
    );
}
exports.getRepoRootDir = getRepoRootDir;
function getDirIsRepoRoot(rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield getRepoRootDir(rootDir)) === rootDir;
    });
}
exports.getDirIsRepoRoot = getDirIsRepoRoot;
function buildDiffFileArgs(pathMatches, ignoreMatches) {
    let args = [];
    if (pathMatches === null) {
        args.push('.'); // all
    }
    else {
        for (let pathMatch of pathMatches) {
            args.push(pathMatch);
        }
    }
    for (let ignoreMatch of ignoreMatches) {
        args.push(':!' + ignoreMatch);
    }
    return args;
}
