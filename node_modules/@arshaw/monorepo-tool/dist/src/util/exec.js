"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
class ExecError extends Error {
    constructor(exitCode, output, message) {
        super(message);
        this.exitCode = exitCode;
        this.output = output;
    }
}
exports.ExecError = ExecError;
/*
stdio inspired from
https://stackoverflow.com/questions/14332721/node-js-spawn-child-process-and-get-terminal-output-live
*/
function execLive(cmd, cwd) {
    if (!cmd[0]) {
        throw new Error('Must supply a file to execute');
    }
    return new Promise((resolve, reject) => {
        let child = child_process_1.spawn(cmd[0], cmd.slice(1), {
            cwd,
            stdio: [0, 1, 2]
        });
        child.on('error', (error) => {
            reject(new ExecError(null, error.toString(), error.message));
        });
        child.on('close', (code) => {
            if (code !== 0) {
                reject(new ExecError(code, '', ''));
            }
            else {
                resolve();
            }
        });
    });
}
exports.execLive = execLive;
function execBuffered(cmd, cwd) {
    if (!cmd[0]) {
        throw new Error('Must supply a file to execute');
    }
    return new Promise((resolve, reject) => {
        child_process_1.execFile(cmd[0], cmd.slice(1), {
            encoding: 'utf8',
            cwd
        }, (error, stdout, stderr) => {
            if (error) {
                reject(new ExecError(error.code, stderr, error.message));
            }
            else {
                resolve(stdout);
            }
        });
    });
}
exports.execBuffered = execBuffered;
