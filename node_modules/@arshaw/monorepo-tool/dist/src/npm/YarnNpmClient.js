"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const arg_parse_1 = require("../util/arg-parse");
const AbstractNpmClient_1 = require("./AbstractNpmClient");
class YarnNpmClient extends AbstractNpmClient_1.default {
    constructor() {
        super(...arguments);
        this.baseCmd = 'yarn';
    }
    buildInstallCmd(forceCi, otherArgs) {
        return [this.baseCmd, 'install'].concat(otherArgs);
    }
    buildExecCmd(cmdStr) {
        // pipe directly to bash! no npx equiv! TODO: x-platform compat?
        // TODO: use spawn() with shell:true arg?
        return ['eval', cmdStr];
    }
    buildAddCmd(pkgArgs, otherArgs) {
        return [this.baseCmd, 'add', ...pkgArgs, ...otherArgs];
    }
    buildRemoveCmd(pkgArgs, otherArgs) {
        return [this.baseCmd, 'remove', ...pkgArgs, ...otherArgs];
    }
    queryAddConfig(args, rootDir) {
        return __awaiter(this, void 0, void 0, function* () {
            let doDev = arg_parse_1.extractNamedFlag(args, ['dev', 'D'], false);
            let doPeer = arg_parse_1.extractNamedFlag(args, ['peer', 'P'], false);
            let doOptional = arg_parse_1.extractNamedFlag(args, ['optional', 'O'], false);
            let doExact = arg_parse_1.extractNamedFlag(args, ['exact', 'E'], false);
            let doTilde = arg_parse_1.extractNamedFlag(args, ['tilde', 'T'], false);
            let depType;
            if (doPeer) {
                throw new errors_1.UnsupportedDepTypeError('peerDependencies');
            }
            else if (doDev) {
                depType = 'devDependencies';
            }
            else if (doOptional) {
                depType = 'optionalDependencies';
            }
            else {
                depType = 'dependencies';
            }
            return { depType, versionPrefix: doTilde ? '~' : '^', versionForceExact: doExact };
        });
    }
    queryVersionConfig(args, rootDir) {
        return Promise.all([
            this.queryConfigVal('version-tag-prefix', args, rootDir),
            this.queryConfigVal('version-git-message', args, rootDir),
            this.queryConfigFlag('version-sign-git-tag', args, rootDir),
            this.queryConfigFlag('version-git-tag', args, rootDir),
            this.queryConfigFlag('version-commit-hooks', args, rootDir)
        ]).then(([tagPrefix, gitMessage, signGitTag, gitTag, commitHooks]) => {
            let versionExact = arg_parse_1.extractNamedVal(args, 'new-version') || '';
            let versionReleaseType = '';
            let versionIgnoreScripts = arg_parse_1.extractNamedFlag(args, 'ignore-scripts', false);
            let isMajor = arg_parse_1.extractNamedVal(args, 'major');
            let isMinor = arg_parse_1.extractNamedVal(args, 'minor');
            let isPatch = arg_parse_1.extractNamedVal(args, 'patch');
            let force = arg_parse_1.extractNamedFlag(args, ['force', 'f'], false); // not a real Yarn setting
            if (!versionExact) {
                if (isMajor) {
                    versionReleaseType = 'major';
                }
                else if (isMinor) {
                    versionReleaseType = 'minor';
                }
                else if (isPatch) {
                    versionReleaseType = 'patch';
                }
            }
            return {
                versionExact,
                versionReleaseType,
                versionPreid: '',
                versionAllowSame: true,
                versionIgnoreScripts,
                gitForce: force,
                gitTagEnabled: gitTag,
                gitMessage: gitMessage,
                gitTagPrefix: tagPrefix,
                gitTagSign: signGitTag,
                gitCommitHooks: commitHooks,
                gitCommitArgs: args
            };
        });
    }
    queryGitTagPrefix(rootDir) {
        return this.queryConfigVal('version-tag-prefix', [], rootDir);
    }
}
exports.default = YarnNpmClient;
