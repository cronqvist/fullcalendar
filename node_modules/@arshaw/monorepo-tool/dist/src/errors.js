"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class LibError extends Error {
}
exports.LibError = LibError;
class MissingConfigError extends LibError {
    constructor(cwd) {
        super(`Couldn\'t find config file in directory or parent directories. In ${cwd}`);
    }
}
exports.MissingConfigError = MissingConfigError;
class RootInnerRefError extends LibError {
    constructor(depType, innerPkgName) {
        super(`Root package should not reference child package ${innerPkgName} from ${depType}`);
    }
}
exports.RootInnerRefError = RootInnerRefError;
class InnerInnerRefError extends LibError {
    constructor(subjectPkgId, searchPkgName, refVerRange, actualVersion) {
        super(`Pkg ${subjectPkgId} accessing ${searchPkgName}` +
            (refVerRange ? `@${refVerRange}` : '') + ' ' +
            (actualVersion
                ? `which is out range with ${actualVersion}`
                : 'which doesn\'t have a version'));
    }
}
exports.InnerInnerRefError = InnerInnerRefError;
class InnerRefError extends LibError {
    constructor(searchPkgName, searchPkgVersionRange, actualVersion) {
        super(`Problem referencing ${searchPkgName}@${searchPkgVersionRange}. Current version is ${actualVersion}`);
    }
}
exports.InnerRefError = InnerRefError;
class PkgNameCollisionError extends LibError {
    constructor(pkgName) {
        super(`Multiple packages with same name "${pkgName}"`);
    }
}
exports.PkgNameCollisionError = PkgNameCollisionError;
class CmdNotFoundError extends LibError {
    constructor(cmd) {
        super(`Command '${cmd}' is not supported`);
    }
}
exports.CmdNotFoundError = CmdNotFoundError;
class LinkInnerPkgNoVersionError extends LibError {
    constructor(innerPkgName) {
        super(`Can't link to package ${innerPkgName} because it has no defined version`);
    }
}
exports.LinkInnerPkgNoVersionError = LinkInnerPkgNoVersionError;
class FailedNpmScript extends LibError {
    constructor(scriptName) {
        super(`Failed executing NPM script '${scriptName}'`);
    }
}
exports.FailedNpmScript = FailedNpmScript;
class MissingDistJsonError extends LibError {
    constructor(pkgId) {
        super(`Missing dist package.json for package '${pkgId}'`);
    }
}
exports.MissingDistJsonError = MissingDistJsonError;
class NoRepoRootError extends LibError {
    constructor(dir) {
        super(`A git repo does not exist at ${dir}`);
    }
}
exports.NoRepoRootError = NoRepoRootError;
class UnsupportedDepTypeError extends LibError {
    constructor(depType) {
        super(`The dependency type '${depType}' is not supported for this operation`);
    }
}
exports.UnsupportedDepTypeError = UnsupportedDepTypeError;
class VersionishNotFoundError extends LibError {
    constructor(versionish) {
        super(`The version specifier ${versionish} could not be found`);
    }
}
exports.VersionishNotFoundError = VersionishNotFoundError;
class UnknownVersionRangeBumpError extends LibError {
    constructor(userPkgId, depPkgId, versionRange) {
        super(`Cannot bump ${depPkgId} becauses uses non-standard version range '${versionRange}'. Please do it yourself first.`);
    }
}
exports.UnknownVersionRangeBumpError = UnknownVersionRangeBumpError;
class GitCleanWorkingTreeError extends LibError {
    constructor(dir) {
        super(`Need clean git working tree in ${dir}`);
    }
}
exports.GitCleanWorkingTreeError = GitCleanWorkingTreeError;
class PubPkgNeedsNameError extends LibError {
    constructor(pkgDir) {
        super(`Want to publish package '${pkgDir}' but doesn't have a name`);
    }
}
exports.PubPkgNeedsNameError = PubPkgNeedsNameError;
