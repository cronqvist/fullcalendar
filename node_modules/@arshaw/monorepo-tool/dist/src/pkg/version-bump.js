"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
const prompts = require("prompts");
const log_1 = require("../util/log");
const version_1 = require("../util/version");
const pretty_task_1 = require("../util/pretty-task");
const async_1 = require("../util/async");
const errors_1 = require("../errors");
const changed_1 = require("./changed");
const version_utils_1 = require("./version-utils");
const dep_objs_1 = require("./dep-objs");
const GitRepo_1 = require("../git/GitRepo");
const PkgGitRepo_1 = require("../git/PkgGitRepo");
const GitRepo_2 = require("../git/GitRepo");
const hash_1 = require("../util/hash");
function bumpVersionsWithPrompt(monoRepo, subjectPkgs, versionConfig, forceAllPkgs) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = yield prepareVersionBump(monoRepo, subjectPkgs, versionConfig, forceAllPkgs);
        if (res) {
            if (res.mods.length) {
                let okay = yield confirmMods(res.mods, res.newVersion);
                if (okay) {
                    return res.execute();
                }
            }
            else {
                console.log('No packages to bump');
            }
        }
    });
}
exports.bumpVersionsWithPrompt = bumpVersionsWithPrompt;
/*
TODO: ordering of pkgs by who-depends-on-who
NOTE: gitTagEnabled means commit+tag
*/
function prepareVersionBump(monoRepo, subjectPkgs, versionConfig, forceAllPkgs) {
    return __awaiter(this, void 0, void 0, function* () {
        // SETUP
        // ----------------------------------------------------------------------------------------------------
        let { rootDir, rootPkg, npmClient } = monoRepo;
        if (versionConfig.gitTagEnabled && !versionConfig.gitForce) {
            yield checkCleanTree(rootDir);
        }
        let oldVersion = version_utils_1.computeBaseVersion(rootPkg, subjectPkgs);
        let newVersion = versionConfig.versionExact ||
            semver.inc(oldVersion || '0.0.0', versionConfig.versionReleaseType || 'patch');
        if (!newVersion) {
            throw new Error('Could not compute new version number'); // TODO: prettier error if old version was bad
        }
        log_1.log(`oldVersion: ${oldVersion}, newVersion: ${newVersion}`);
        // packages that need a version bump because of changes
        let namedPkgs = subjectPkgs.filter((pkg) => {
            return Boolean(pkg.jsonData.name);
        });
        let directBumpPkgs = forceAllPkgs
            ? namedPkgs
            : yield changed_1.changedPkgsSincePoint(monoRepo, namedPkgs, oldVersion, []);
        if (!directBumpPkgs.length) {
            console.log();
            console.log('No changed packages');
            console.log();
            return;
        }
        let modMap = buildModMap(directBumpPkgs, newVersion, monoRepo.innerPkgs);
        let modUndos = [];
        // if root package has a version field, make an operation to update that too
        if (rootPkg && ('version' in rootPkg.jsonData)) {
            modMap[rootDir] = { pkg: rootPkg, version: newVersion };
        }
        let allBumpPkgs = hash_1.mapHashToArray(modMap, (mod) => mod.pkg);
        let pkgGitRepo = versionConfig.gitTagEnabled
            ? yield PkgGitRepo_1.buildPkgGitRepo(rootDir, allBumpPkgs)
            : null;
        let isFilesAdded = false;
        // FUNCS
        // ----------------------------------------------------------------------------------------------------
        function execute() {
            return __awaiter(this, void 0, void 0, function* () {
                log_1.log('Running preversion hooks...');
                yield preVersionHook();
                modUndos = yield modifyFiles(modMap);
                if (pkgGitRepo) {
                    yield addFiles(pkgGitRepo, modMap).catch(undoAndReject);
                    isFilesAdded = true;
                }
                log_1.log('Running version hooks...');
                yield versionHook();
                if (pkgGitRepo) {
                    let messageTemplate = versionConfig.gitMessage || '%s'; // TODO: gitMessage is a bad name. have NpmClients default to '%s' ?
                    let message = messageTemplate.replace('%s', newVersion);
                    let committedRepos = []; // yuck
                    yield commitFiles(pkgGitRepo, modMap, versionConfig, message, committedRepos)
                        .catch(undoAndReject);
                    yield async_1.allSettledVoid(committedRepos.map((repo) => {
                        return repo.createTag(versionConfig.gitTagPrefix + newVersion, message, versionConfig.gitTagSign).catch((err) => {
                            console.error('Repo with problem making tag: ' + repo.rootDir);
                            throw err;
                        });
                    }));
                }
                log_1.log('Running postversion hooks...');
                yield postVersionHook();
            });
        }
        function undo() {
            return __awaiter(this, void 0, void 0, function* () {
                if (isFilesAdded) {
                    yield resetFiles(pkgGitRepo, modMap);
                }
                yield async_1.runParallel(modUndos);
            });
        }
        function undoAndReject(error) {
            return __awaiter(this, void 0, void 0, function* () {
                yield undo(); // undo first
                throw error; // then rethrow error
            });
        }
        function preVersionHook() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!versionConfig.versionIgnoreScripts) {
                    process.env.npm_package_version = oldVersion;
                    yield runNpmScripts(npmClient, modMap, 'preversion').catch(undoAndReject);
                }
            });
        }
        function versionHook() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!versionConfig.versionIgnoreScripts) {
                    process.env.npm_package_version = newVersion;
                    yield runNpmScripts(npmClient, modMap, 'version').catch(undoAndReject);
                }
            });
        }
        function postVersionHook() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!versionConfig.versionIgnoreScripts) {
                    // npm_package_version will already be set to newVersion
                    yield runNpmScripts(npmClient, modMap, 'postversion'); // don't undo with undoAndReject
                }
            });
        }
        return { mods: Object.values(modMap), newVersion, execute };
    });
}
exports.prepareVersionBump = prepareVersionBump;
// MOD CREATION
// ----------------------------------------------------------------------------------------------------
function buildModMap(directBumpPkgs, newVersion, allInnerPkgs) {
    let modMap = {};
    for (let pkg of directBumpPkgs) {
        if (pkg.jsonData.version !== newVersion) {
            let mod = processPkgBump(pkg, newVersion, allInnerPkgs, modMap);
            mod.directlyChanged = true;
        }
    }
    return modMap;
}
/*
Will populate the modifications that must happen if ONLY pkg were to be bumped. The [recursive] caller will add-in
the modifications to pkg's dependencies later
*/
function processPkgBump(pkg, newVersion, allInnerPkgs, modMap) {
    let mod = modMap[pkg.dir];
    if (!mod) {
        mod = modMap[pkg.dir] = { pkg };
        let pkgName = pkg.jsonData.name;
        if (pkgName) { // can others refer to it?...
            mod.version = newVersion; // ...if so, give it a version bump
            // identify other pkgs that refer to this one
            for (let userPkg of allInnerPkgs) {
                let matchedDeps = dep_objs_1.whitelistDeps(userPkg.jsonData, pkgName);
                let updatedDeps = {};
                for (let depType in matchedDeps) {
                    let existingRange = matchedDeps[depType][pkgName];
                    if (!semver.satisfies(newVersion, existingRange)) {
                        let newVerRange = version_1.updateVerRange(existingRange, newVersion);
                        if (!newVerRange) {
                            throw new errors_1.UnknownVersionRangeBumpError(userPkg.readableId(), pkg.readableId(), existingRange);
                        }
                        else {
                            log_1.log(userPkg.readableId(), 'uses out of date', depType, pkgName, newVerRange);
                            updatedDeps[depType] = { [pkgName]: newVerRange };
                        }
                    }
                }
                if (Object.keys(updatedDeps).length) {
                    let depMod = processPkgBump(userPkg, newVersion, allInnerPkgs, modMap);
                    if (depMod.deps) { // has some updated deps from a different mod
                        depMod.deps = dep_objs_1.mergeDeps(depMod.deps, updatedDeps);
                    }
                    else {
                        depMod.deps = updatedDeps;
                    }
                }
            }
        }
    }
    return mod;
}
// MOD EXECUTION
// ----------------------------------------------------------------------------------------------------
function modifyFiles(modMap) {
    return async_1.allSettled(hash_1.mapHashToArray(modMap, (mod, dir) => {
        return modifyPkgFiles(modMap[dir]);
    }));
}
function modifyPkgFiles(mod) {
    return __awaiter(this, void 0, void 0, function* () {
        let { pkg } = mod;
        let newJsonData = Object.assign({}, pkg.jsonData);
        if (mod.version) {
            newJsonData.version = mod.version;
        }
        if (mod.deps) {
            Object.assign(newJsonData, dep_objs_1.mergeDeps(newJsonData, mod.deps) // awkward
            );
        }
        return pkg.updateJson(newJsonData);
    });
}
// GIT UTILS
// ----------------------------------------------------------------------------------------------------
function checkCleanTree(rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        let isGit = yield GitRepo_1.getDirIsRepoRoot(rootDir); // BAD: done again for buildPkgGitRepo
        let gitRepo = new GitRepo_2.default(rootDir);
        if (isGit) {
            let isDirty = yield gitRepo.isDirty();
            if (isDirty) {
                throw new errors_1.GitCleanWorkingTreeError(rootDir);
            }
        }
    });
}
function addFiles(pkgGitRepo, modMap) {
    function addOwnFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let pkg of pkgGitRepo.pkgs) {
                if (modMap[pkg.dir]) {
                    yield pkgGitRepo.addFile(pkg.jsonPath); // wait because can't do concurrent write ops on same repo
                }
            }
        });
    }
    function addSubmoduleFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            return async_1.allSettledVoid(pkgGitRepo.submodules.map((submodule) => {
                return addFiles(submodule, modMap);
            }));
        });
    }
    return async_1.allSettledVoid([
        addOwnFiles(),
        addSubmoduleFiles()
    ]);
}
function resetFiles(pkgGitRepo, modMap) {
    function resetOwnFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let pkg of pkgGitRepo.pkgs) {
                if (modMap[pkg.dir]) {
                    yield pkgGitRepo.resetFile(pkg.jsonPath); // wait because can't do concurrent write ops on same repo
                }
            }
        });
    }
    function resetSubmoduleFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            return async_1.allSettledVoid(pkgGitRepo.submodules.map((submodule) => {
                return resetFiles(submodule, modMap);
            }));
        });
    }
    return async_1.allSettledVoid([
        resetOwnFiles(),
        resetSubmoduleFiles()
    ]);
}
/*
all files have already been added except for submodule refs
*/
function commitFiles(pkgGitRepo, modMap, config, message, committedRepos // by reference. TODO: move away from this
) {
    return __awaiter(this, void 0, void 0, function* () {
        let { submodules } = pkgGitRepo;
        function commitSubmodules() {
            return __awaiter(this, void 0, void 0, function* () {
                return async_1.allSettled(submodules.map((submodule) => {
                    return commitFiles(submodule, modMap, config, message, committedRepos);
                }));
            });
        }
        function hasOwnMods() {
            for (let pkg of pkgGitRepo.pkgs) {
                if (modMap[pkg.dir]) {
                    return true;
                }
            }
            return false;
        }
        let isSubmodulesCommited = yield commitSubmodules();
        let hasSubmoduleCommits = false;
        // add each submodule reference
        for (let i = 0; i < submodules.length; i++) {
            if (isSubmodulesCommited[i]) {
                yield pkgGitRepo.addFile(submodules[i].rootDir); // can only do one at a time
                hasSubmoduleCommits = true;
            }
        }
        if (hasSubmoduleCommits || hasOwnMods()) {
            yield pkgGitRepo.commit(message, config.gitCommitHooks, config.gitCommitArgs);
            committedRepos.push(pkgGitRepo);
            return true;
        }
        else {
            return false;
        }
    });
}
// NPM UTILS
// ----------------------------------------------------------------------------------------------------
function runNpmScripts(npmClient, modMap, scriptName) {
    return __awaiter(this, void 0, void 0, function* () {
        let pkgsWithScripts = [];
        for (let dir in modMap) {
            let pkg = modMap[dir].pkg;
            if (pkg.hasScript(scriptName)) {
                pkgsWithScripts.push(pkg);
            }
        }
        // TODO: use EXEC utils somehow. not DRY like this
        let tasks = pkgsWithScripts.map((pkg) => ({
            label: pkg.readableId() + ' (script(bump): ' + scriptName + ')',
            func() {
                return pkg.runScript(npmClient, scriptName, false); // bufferOutput=false
            }
        }));
        // better to do serial in case there are interactive command prompts
        // TODO: make a setting to toggle this?
        // TODO: if change, will need to switch bufferOutput above
        return pretty_task_1.runPrettySerial(tasks).catch(() => {
            throw new errors_1.FailedNpmScript(scriptName);
        });
    });
}
// COMMAND LINE UI
// ----------------------------------------------------------------------------------------------------
function outputMods(mods, newVersion) {
    let lines = [];
    for (let mod of mods) {
        let parts = [];
        if (mod.directlyChanged) {
            parts.push('CHANGED');
        }
        if (mod.deps) {
            parts.push('DEPS-BUMPED');
        }
        lines.push(parts.join('/') + ' ' + (mod.pkg.readableId()));
    }
    lines.sort();
    console.log();
    console.log('Will bump the following packages to ' + newVersion + ':');
    console.log();
    for (let line of lines) {
        console.log('  ', line);
    }
    console.log();
}
function confirmMods(mods, newVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        outputMods(mods, newVersion);
        let answer = yield prompts({
            name: 'ok',
            type: 'confirm',
            message: 'Is this okay?',
            initial: false
        });
        return answer.ok;
    });
}
