"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const async_1 = require("../util/async");
const dep_json_fs_1 = require("./dep-json-fs");
const dep_objs_1 = require("./dep-objs");
const symlink_1 = require("./symlink");
function addDepsToPkgs(monoRepo, subjectPkgs, pkgAddArgs, npmRunTimeArgs, addConfig) {
    let allInnerPkgsByName = monoRepo.innerPkgsByName;
    let { pkgsByName, externalPkgArgs } = dep_objs_1.processPkgArgs(pkgAddArgs, monoRepo.innerPkgsByName);
    return async_1.allSettledVoid(subjectPkgs.map((pkg) => addDepsToPkg(monoRepo, pkg, allInnerPkgsByName, pkgsByName, externalPkgArgs, npmRunTimeArgs, addConfig)));
}
exports.addDepsToPkgs = addDepsToPkgs;
function addDepsToPkg(monoRepo, subjectPkg, allInnerPkgsByName, innerPkgsByName, // the ones to add
externalPkgArgs, // the ones to add
npmRunTimeArgs, addConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        // install external deps. wait for package.json to be written
        yield dep_json_fs_1.addExternalDeps(monoRepo, subjectPkg, allInnerPkgsByName, externalPkgArgs, npmRunTimeArgs);
        // install inner deps. will write to package.json also
        yield Promise.all([
            dep_json_fs_1.addDepEntries(subjectPkg, buildNewDeps(innerPkgsByName, addConfig)),
            symlink_1.writeExactSymlinksForPkg(subjectPkg, innerPkgsByName)
        ]);
    });
}
exports.addDepsToPkg = addDepsToPkg;
function buildNewDeps(innerPkgsByName, addConfig) {
    let { depType } = addConfig;
    let deps = {};
    if (depType) { // otherwise, we dont want to write at all
        for (let innerPkgName in innerPkgsByName) {
            let version = innerPkgsByName[innerPkgName].jsonData.version;
            if (!version) {
                throw new errors_1.LinkInnerPkgNoVersionError(innerPkgName);
            }
            let versionRange;
            if (addConfig.versionForceExact) {
                versionRange = version;
            }
            else {
                versionRange = addConfig.versionPrefix + version;
            }
            ;
            (deps[depType] || (deps[depType] = {}))[innerPkgName] = versionRange;
        }
    }
    return deps;
}
