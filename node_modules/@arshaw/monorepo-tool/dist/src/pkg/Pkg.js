"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const fs = require("fs");
const path_1 = require("path");
const log_1 = require("../util/log");
const exec_1 = require("../util/exec");
const errors_1 = require("../errors");
const readFile = util_1.promisify(fs.readFile);
const writeFile = util_1.promisify(fs.writeFile);
class Pkg {
    constructor(dir, npmClientArgs) {
        this.dir = dir;
        this.npmClientArgs = npmClientArgs;
        this.jsonPath = path_1.join(this.dir, 'package.json');
    }
    /*
    Should always be called right after instantiation.
    TODO: write a factory function that does all this, but works with Pkg sublasses somehow.
    */
    loadJson() {
        return readFile(this.jsonPath, { encoding: 'utf8' }).then((jsonText) => {
            this.jsonText = jsonText;
            return (this.jsonData = JSON.parse(jsonText));
        });
    }
    updateJson(newJsonData) {
        return __awaiter(this, void 0, void 0, function* () {
            let oldJsonData = this.jsonData;
            let oldJsonText = this.jsonText;
            let newJsonText = JSON.stringify(newJsonData, null, '  ') + '\n'; // TODO: use old text to determine end
            log_1.log('Writing mods to', this.jsonPath, newJsonData);
            yield writeFile(this.jsonPath, newJsonText, { encoding: 'utf8' });
            this.jsonData = newJsonData;
            this.jsonText = newJsonText;
            return () => __awaiter(this, void 0, void 0, function* () {
                log_1.log('Undoing mods to', this.jsonPath);
                yield writeFile(this.jsonPath, oldJsonText, { encoding: 'utf8' });
                this.jsonData = oldJsonData;
                this.jsonText = oldJsonText;
            });
        });
    }
    runScript(npmClient, scriptName, buffer = false) {
        let cmd = this.buildScriptCmd(npmClient, scriptName);
        if (cmd) {
            log_1.log('runcmd', cmd, buffer, this.dir);
            if (buffer) {
                return exec_1.execBuffered(cmd, this.dir);
            }
            else {
                return exec_1.execLive(cmd, this.dir).then(() => '');
            }
        }
        else {
            return Promise.resolve('');
        }
    }
    hasScript(scriptName) {
        return scriptName in (this.jsonData.scripts || {});
    }
    buildScriptCmd(npmClient, scriptName) {
        let scriptCmdStr = (this.jsonData.scripts || {})[scriptName];
        if (scriptCmdStr) {
            return npmClient.buildExecCmd(scriptCmdStr);
        }
        return null;
    }
    readableId() {
        return this.jsonData.name || 'root'; // assuming root is a bad idea
    }
}
exports.default = Pkg;
function hashPkgsByName(pkgs) {
    let pkgsByName = {};
    for (let pkg of pkgs) {
        let pkgName = pkg.jsonData.name;
        if (pkgName) {
            if (pkgsByName[pkgName]) {
                throw new errors_1.PkgNameCollisionError(pkgName);
            }
            else {
                pkgsByName[pkgName] = pkg;
            }
        }
    }
    return pkgsByName;
}
exports.hashPkgsByName = hashPkgsByName;
function hashPkgsByDir(pkgs) {
    let pkgsByDir = {};
    for (let pkg of pkgs) {
        pkgsByDir[pkg.dir] = pkg;
    }
    return pkgsByDir;
}
exports.hashPkgsByDir = hashPkgsByDir;
