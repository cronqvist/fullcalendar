"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const log_1 = require("../util/log");
const exec_1 = require("../util/exec");
const hash_1 = require("../util/hash");
const dep_objs_1 = require("./dep-objs");
const symlink_1 = require("./symlink");
function addExternalDeps(monoRepo, subjectPkg, allInnerPkgsByName, externalPkgArgs, npmRunTimeArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!externalPkgArgs.length) {
            return;
        }
        let npmArgs = monoRepo.getCmdNpmArgs('add').concat(subjectPkg.npmClientArgs, npmRunTimeArgs);
        let cmd = monoRepo.npmClient.buildAddCmd(externalPkgArgs, npmArgs);
        yield execNpmTask(subjectPkg, allInnerPkgsByName, () => exec_1.execLive(cmd, subjectPkg.dir));
    });
}
exports.addExternalDeps = addExternalDeps;
function removeExternalDeps(monoRepo, subjectPkg, allInnerPkgsByName, externalPkgArgs, npmRunTimeArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!externalPkgArgs.length) {
            return;
        }
        let npmArgs = monoRepo.getCmdNpmArgs('add').concat(subjectPkg.npmClientArgs, npmRunTimeArgs);
        let cmd = monoRepo.npmClient.buildRemoveCmd(externalPkgArgs, npmArgs);
        yield execNpmTask(subjectPkg, allInnerPkgsByName, () => exec_1.execLive(cmd, subjectPkg.dir));
    });
}
exports.removeExternalDeps = removeExternalDeps;
/*
Accepts a generic task that modifies a package's package.json, and allows it to happen
amidst entries that point to internal packages, which would normally choked the npm client.
*/
function execNpmTask(subjectPkg, allInnerPkgsByName, npmTask) {
    return __awaiter(this, void 0, void 0, function* () {
        let origInnerDeps = dep_objs_1.whitelistDeps(subjectPkg.jsonData, allInnerPkgsByName);
        let origDepFlags = dep_objs_1.depsToFlags(origInnerDeps);
        let undoJson = yield removeDepEntries(subjectPkg, origDepFlags); // remove inner-package from package.json
        function undoAndReject() {
            return undoJson().then(() => Promise.reject());
        }
        yield npmTask().then(() => Promise.all([
            // defacto-npm kills all linked packages after almost any action. restore
            symlink_1.writeExactSymlinksForPkg(subjectPkg, hash_1.filterHash(allInnerPkgsByName, origDepFlags)),
            // read the changes in package.json from npmTask
            subjectPkg.loadJson().then(() => addDepEntries(subjectPkg, origInnerDeps), undoAndReject)
        ]), undoAndReject);
    });
}
// Change deps in package.json
// ----------------------------------------------------------------------------------------------------
function addDepEntries(subjectPkg, deps) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Object.keys(deps).length) {
            return () => Promise.resolve();
        }
        let newJsonData = Object.assign({}, subjectPkg.jsonData); // copy
        // combine new deps with existing ones
        for (let depType in deps) {
            newJsonData[depType] = Object.assign({}, newJsonData[depType] || {}, deps[depType]);
        }
        return yield subjectPkg.updateJson(newJsonData);
    });
}
exports.addDepEntries = addDepEntries;
function removeDepEntries(subjectPkg, pkgHash) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Object.keys(pkgHash).length) {
            log_1.log(`No need to remove pkgs from ${subjectPkg.jsonPath}`, Object.keys(pkgHash));
            return () => Promise.resolve();
        }
        log_1.log(`Removing pkgs from ${subjectPkg.jsonPath}`, Object.keys(pkgHash));
        let newJsonData = Object.assign(dep_objs_1.removeDepGroups(subjectPkg.jsonData), // remove all deps
        dep_objs_1.blacklistDeps(subjectPkg.jsonData, pkgHash) // add-back deps without certain packages
        );
        return yield subjectPkg.updateJson(newJsonData);
    });
}
exports.removeDepEntries = removeDepEntries;
