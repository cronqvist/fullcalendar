"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
const errors_1 = require("../errors");
const hash_1 = require("../util/hash");
const version_1 = require("../util/version");
const DEP_TYPES = ['dependencies', 'devDependencies', 'optionalDependencies', 'peerDependencies'];
const INSTALLABLE_DEP_TYPES = ['dependencies', 'devDependencies', 'optionalDependencies'];
function mapInstallableDeps(deps, func) {
    let res = [];
    for (let depType of INSTALLABLE_DEP_TYPES) {
        let depGroup = deps[depType];
        if (depGroup) {
            for (let pkgName in depGroup) {
                res.push(func(pkgName, depGroup[pkgName]));
            }
        }
    }
    return res;
}
exports.mapInstallableDeps = mapInstallableDeps;
/*
removes the dependencies/devDependencies/etc keys from an arbitrary object
*/
function removeDepGroups(props) {
    let copy = Object.assign({}, props);
    for (let depType of INSTALLABLE_DEP_TYPES) {
        delete copy[depType];
    }
    return copy;
}
exports.removeDepGroups = removeDepGroups;
function mergeDeps(deps0, deps1) {
    let res = {};
    for (let depType of DEP_TYPES) {
        if (deps0[depType] || deps1[depType]) {
            res[depType] = Object.assign({}, deps0[depType] || {}, deps1[depType] || {});
        }
    }
    return res;
}
exports.mergeDeps = mergeDeps;
/*
Remove entries based on a filter function
*/
function filterDeps(deps, func) {
    let res = {};
    for (let depType of DEP_TYPES) {
        let depGroup = deps[depType];
        if (depGroup) {
            let resGroup = {};
            let isAny = false;
            for (let pkgName in depGroup) {
                let funcRes = func(pkgName, depGroup[pkgName]);
                if (typeof funcRes === 'string') {
                    resGroup[pkgName] = funcRes;
                    isAny = true;
                }
                else if (funcRes) {
                    resGroup[pkgName] = depGroup[pkgName];
                    isAny = true;
                }
            }
            if (isAny) {
                res[depType] = resGroup;
            }
        }
    }
    return res;
}
exports.filterDeps = filterDeps;
function whitelistDeps(deps, whitelist) {
    let hash = parseFilterArg(whitelist);
    return filterDeps(deps, (pkgName) => {
        return hash[pkgName];
    });
}
exports.whitelistDeps = whitelistDeps;
function blacklistDeps(deps, blacklist) {
    let hash = parseFilterArg(blacklist);
    return filterDeps(deps, (pkgName) => {
        return !hash[pkgName];
    });
}
exports.blacklistDeps = blacklistDeps;
/*
Given a list of args that might be given to `npm install ...`, decides which ones
are internal packages versus external. Makes sure internal packages match the request version.
*/
function processPkgArgs(args, innerPkgsByName) {
    let pkgsByName = {};
    let externalPkgArgs = [];
    for (let arg of args) {
        let [pkgName, pkgVerRange] = version_1.parsePkgVersionRangeArg(arg);
        let innerPkg = innerPkgsByName[pkgName];
        if (innerPkg) {
            let actualVersion = innerPkg.jsonData.version;
            if (actualVersion &&
                pkgVerRange &&
                semver.valid(pkgVerRange) && // not a tag or something else
                !semver.satisfies(actualVersion, pkgVerRange)) {
                throw new errors_1.InnerRefError(pkgName, pkgVerRange, actualVersion);
            }
            pkgsByName[pkgName] = innerPkg;
        }
        else {
            externalPkgArgs.push(arg);
        }
    }
    return { pkgsByName, externalPkgArgs };
}
exports.processPkgArgs = processPkgArgs;
function depsToFlags(deps) {
    let res = {};
    for (let depType of DEP_TYPES) {
        let depGroup = deps[depType];
        if (depGroup) {
            for (let pkgName in depGroup) {
                res[pkgName] = true;
            }
        }
    }
    return res;
}
exports.depsToFlags = depsToFlags;
function parseFilterArg(arg) {
    if (typeof arg === 'string') {
        return { [arg]: true };
    }
    else if (Array.isArray(arg)) {
        return hash_1.arrayToHash(arg);
    }
    else {
        return arg;
    }
}
