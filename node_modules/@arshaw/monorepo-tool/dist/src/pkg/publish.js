"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const prompts = require("prompts");
const errors_1 = require("../errors");
const async_1 = require("../util/async");
const exec_1 = require("../util/exec");
const log_1 = require("../util/log");
const pretty_task_1 = require("../util/pretty-task");
const version_utils_1 = require("./version-utils");
function publishPkgsWithPrompt(monoRepo, subjectPkgs, npmArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = yield preparePublish(monoRepo, subjectPkgs, npmArgs);
        if (res) {
            let okay = yield confirmPublish(res.pkgs, res.version);
            if (okay) {
                return res.execute();
            }
        }
    });
}
exports.publishPkgsWithPrompt = publishPkgsWithPrompt;
/*
TODO: ordering of pkgs by who-depends-on-who
TODO: more robust settings about knowing which packages to publish
keep package.json publishConfig in mind:
  https://docs.npmjs.com/files/package.json#publishconfig
*/
function preparePublish(monoRepo, subjectPkgs, npmRunTimeArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        let currentVersion = version_utils_1.computeBaseVersion(monoRepo.rootPkg, subjectPkgs);
        let isPublics = yield async_1.allSettled(subjectPkgs.map((pkg) => __awaiter(this, void 0, void 0, function* () {
            let distData = yield pkg.queryPublishJsonData();
            if (!distData.private) {
                if (!distData.name) {
                    throw new errors_1.PubPkgNeedsNameError(pkg.relDir);
                }
                return true;
            }
            return false;
        })));
        let queuedPkgs = subjectPkgs.filter((pkg, i) => {
            return pkg.jsonData.version === currentVersion && isPublics[i];
        });
        function execute() {
            return __awaiter(this, void 0, void 0, function* () {
                let { rootPkg, npmClient } = monoRepo;
                if (rootPkg) {
                    yield rootPkg.runScript(npmClient, 'prepublish');
                    yield rootPkg.runScript(npmClient, 'prepare');
                    yield rootPkg.runScript(npmClient, 'prepublishOnly');
                }
                let tasks = queuedPkgs.map((pkg) => ({
                    label: pkg.readableId(),
                    func: () => runPkgPublish(monoRepo, pkg, npmRunTimeArgs)
                }));
                yield pretty_task_1.runPrettyParallel(tasks);
                if (rootPkg) {
                    yield rootPkg.runScript(npmClient, 'publish');
                    yield rootPkg.runScript(npmClient, 'postpublish');
                }
            });
        }
        return { version: currentVersion, pkgs: queuedPkgs, execute };
    });
}
exports.preparePublish = preparePublish;
function runPkgPublish(monoRepo, pkg, npmRunTimeArgs) {
    let npmArgs = monoRepo.getCmdNpmArgs('publish').concat(pkg.npmClientArgs, npmRunTimeArgs);
    let cmd = monoRepo.npmClient.buildPublishCmd(npmArgs);
    log_1.log('PUBLISH CMD', cmd.join(' '), 'in', pkg.distDir || pkg.dir);
    return exec_1.execBuffered(cmd, pkg.distDir || pkg.dir);
}
function confirmPublish(pkgs, version) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log();
        console.log('Will publish the following packages:');
        console.log();
        for (let pkg of pkgs) {
            console.log('  ' + version + ' ' + pkg.readableId());
        }
        console.log();
        let answer = yield prompts({
            name: 'ok',
            type: 'confirm',
            message: 'Is this okay?',
            initial: false
        });
        return answer.ok;
    });
}
