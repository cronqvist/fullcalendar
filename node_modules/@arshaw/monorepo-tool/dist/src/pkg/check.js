"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
const dep_objs_1 = require("./dep-objs");
const errors_1 = require("../errors");
// TODO: check that a package isnt referring to itself
function ensureMonoRepoHealth(monoRepo) {
    let { rootPkg, innerPkgs, innerPkgsByName } = monoRepo;
    if (rootPkg) {
        ensureRootHealth(rootPkg, innerPkgsByName);
    }
    ensureInnerHealth(innerPkgs, innerPkgsByName);
}
exports.ensureMonoRepoHealth = ensureMonoRepoHealth;
function ensureRootHealth(rootPkg, innerPkgsByName) {
    for (let innerPkgName in innerPkgsByName) {
        let refs = dep_objs_1.whitelistDeps(rootPkg.jsonData, innerPkgName);
        for (let depType in refs) {
            throw new errors_1.RootInnerRefError(depType, innerPkgName); // TODO: better DepType stategy
        }
    }
}
function ensureInnerHealth(innerPkgs, innerPkgsByName) {
    for (let subjectPkg of innerPkgs) {
        for (let searchPkgName in innerPkgsByName) {
            let searchPkg = innerPkgsByName[searchPkgName];
            let actualVersion = searchPkg.jsonData.version;
            let refs = dep_objs_1.whitelistDeps(subjectPkg.jsonData, searchPkgName);
            for (let depType in refs) {
                let refVerRange = refs[depType][searchPkgName];
                if (refVerRange !== '*') {
                    if (!actualVersion) {
                        throw new errors_1.InnerInnerRefError(subjectPkg.readableId(), searchPkgName);
                    }
                    else if (!semver.satisfies(actualVersion, refVerRange)) {
                        throw new errors_1.InnerInnerRefError(subjectPkg.readableId(), searchPkgName, refVerRange, actualVersion);
                    }
                }
            }
        }
    }
}
