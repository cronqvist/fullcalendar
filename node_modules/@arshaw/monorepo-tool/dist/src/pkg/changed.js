"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const errors_1 = require("../errors");
const PkgGitRepo_1 = require("../git/PkgGitRepo");
const version_utils_1 = require("./version-utils");
const async_1 = require("../util/async");
const log_1 = require("../util/log");
function changedPkgsSincePoint(// TODO: rename from "point"
monoRepo, subjectPkgs, versionish, gitDiffArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        let commitHash = yield version_utils_1.resolveVersionish(monoRepo, subjectPkgs, versionish);
        if (!commitHash) {
            if (versionish) {
                throw new errors_1.VersionishNotFoundError(versionish);
            }
            else {
                return subjectPkgs; // no version yet. return all pkgs
            }
        }
        let pkgGitRepo = yield PkgGitRepo_1.buildPkgGitRepo(monoRepo.rootDir, subjectPkgs);
        log_1.log('versionish', versionish, commitHash);
        return getChangedRepoPkgs(pkgGitRepo, commitHash, gitDiffArgs);
    });
}
exports.changedPkgsSincePoint = changedPkgsSincePoint;
function getChangedRepoPkgs(pkgGitRepo, commitHash, otherGitArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        let ownPromises = pkgGitRepo.pkgs.map((pkg) => {
            let includesAbs = [pkg.dir];
            let ignoresAbs = pkg.ignoreFiles.map((ignoreFile) => path_1.join(pkg.dir, ignoreFile));
            // need to relativize to subrepo root
            let includes = includesAbs.map((path) => path_1.relative(pkgGitRepo.rootDir, path) || '.');
            let ignores = ignoresAbs.map((path) => path_1.relative(pkgGitRepo.rootDir, path) || '.');
            return pkgGitRepo.hasChangesSince(commitHash, includes, ignores, otherGitArgs)
                .then((bool) => bool ? [pkg] : []);
        });
        log_1.log('looking at', pkgGitRepo.rootDir, commitHash);
        let subPromises = pkgGitRepo.submodules.map((submodule) => {
            return pkgGitRepo.getSubmoduleCommit(commitHash, submodule.rootDir).then((subCommit) => {
                if (subCommit) {
                    return getChangedRepoPkgs(submodule, subCommit, otherGitArgs);
                }
                else { // when no associated commit for submodule, means it didnt exist, so its new
                    return submodule.pkgs;
                }
            });
        });
        return async_1.collectResults(ownPromises.concat(subPromises));
    });
}
