"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shell_quote_1 = require("shell-quote");
const exec_1 = require("../util/exec");
const pretty_task_1 = require("../util/pretty-task");
const log_1 = require("../util/log");
function runScriptInPkgs(monoRepo, pkgs, isParallel, runArgs) {
    // let npmRunArgs = monoRepo.getCmdNpmArgs('run') // TODO: somehow pass these in
    let scriptName = runArgs[0]; // TODO: handle other runArgs
    let tasks = [];
    for (let pkg of pkgs) {
        let cmd = pkg.buildScriptCmd(monoRepo.npmClient, scriptName);
        if (cmd) {
            tasks.push({
                label: pkg.readableId() + ' (script(run): ' + scriptName + ')',
                func() {
                    return isParallel
                        ? exec_1.execBuffered(cmd, pkg.dir)
                        : exec_1.execLive(cmd, pkg.dir);
                }
            });
        }
    }
    return isParallel ? pretty_task_1.runPrettyParallel(tasks) : pretty_task_1.runPrettySerial(tasks);
}
exports.runScriptInPkgs = runScriptInPkgs;
function execInPkgs(monoRepo, pkgs, isParallel, cmd) {
    // let npmExecArgs = monoRepo.getCmdNpmArgs('exec') // dont want in exec command
    // nor pkg.npmClientArgs
    log_1.log('execInPkgs', cmd);
    let tasks = pkgs.map((pkg) => ({
        label: pkg.readableId() + '(exec: ' + cmd.join(' ') + ')',
        func() {
            let filteredCmd = monoRepo.npmClient.buildExecCmd(shell_quote_1.quote(cmd)); // with correct path and whatnot
            return isParallel
                ? exec_1.execBuffered(filteredCmd, pkg.dir)
                : exec_1.execLive(filteredCmd, pkg.dir);
        }
    }));
    return isParallel ? pretty_task_1.runPrettyParallel(tasks) : pretty_task_1.runPrettySerial(tasks);
}
exports.execInPkgs = execInPkgs;
