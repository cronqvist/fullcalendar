"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const fs = require("fs");
const path_1 = require("path");
const mkdirpCb = require("mkdirp");
const hash_1 = require("../util/hash");
const async_1 = require("../util/async");
const log_1 = require("../util/log");
const dep_objs_1 = require("./dep-objs");
const dep_file_rm_1 = require("./dep-file-rm");
const mkdirp = util_1.promisify(mkdirpCb);
const fileExists = util_1.promisify(fs.exists);
const copyFile = util_1.promisify(fs.copyFile);
const symlink = util_1.promisify(fs.symlink);
function writeNeededSymlinksForPkgs(subjectPkgs, innerPkgsByName) {
    return async_1.allSettledVoid(subjectPkgs.map((subjectPkg) => writeNeededSymlinksForPkg(subjectPkg, innerPkgsByName)));
}
exports.writeNeededSymlinksForPkgs = writeNeededSymlinksForPkgs;
/*
will only write the symlinks that the package actually uses
*/
function writeNeededSymlinksForPkg(subjectPkg, innerPkgsByName) {
    let flags = dep_objs_1.depsToFlags(subjectPkg.jsonData);
    return async_1.allSettledVoid(hash_1.mapHashToArray(flags, (pkgVersionRange, pkgName) => {
        if (innerPkgsByName[pkgName]) {
            return writePkgSymlink(subjectPkg, pkgName, innerPkgsByName[pkgName]);
        }
        else {
            return Promise.resolve();
        }
    }));
}
exports.writeNeededSymlinksForPkg = writeNeededSymlinksForPkg;
function writeExactSymlinksForPkg(subjectPkg, addInnerPkgsByName) {
    return async_1.allSettledVoid(hash_1.mapHashToArray(addInnerPkgsByName, (pkg, pkgName) => {
        return writePkgSymlink(subjectPkg, pkgName, pkg);
    }));
}
exports.writeExactSymlinksForPkg = writeExactSymlinksForPkg;
function writePkgSymlink(subjectPkg, otherPkgName, otherPkg) {
    return __awaiter(this, void 0, void 0, function* () {
        yield dep_file_rm_1.removePkgDepFile(subjectPkg, otherPkgName); // clear the old file
        // the symlink file itself
        let linkFile = path_1.join(subjectPkg.dir, 'node_modules', otherPkgName);
        let linkDir = path_1.dirname(linkFile);
        yield mkdirp(linkDir);
        let targetDir = otherPkg.distDir || otherPkg.dir;
        log_1.log('writing symlink to', otherPkg.readableId(), targetDir);
        // ensure the pointed-do package has a package.json
        if (otherPkg.distDir) {
            let distJsonPath = path_1.join(targetDir, 'package.json');
            let distJsonExists = yield fileExists(distJsonPath);
            if (!distJsonExists) {
                let origJsonPath = path_1.join(otherPkg.dir, 'package.json');
                yield mkdirp(targetDir);
                yield copyFile(origJsonPath, distJsonPath);
            }
        }
        let relTarget = path_1.relative(linkDir, targetDir);
        log_1.log('writing link', linkFile, 'content:', relTarget);
        yield symlink(relTarget, linkFile);
    });
}
exports.writePkgSymlink = writePkgSymlink;
