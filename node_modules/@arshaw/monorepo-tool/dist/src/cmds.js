"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const path_2 = require("./util/path");
const arg_parse_1 = require("./util/arg-parse");
const errors_1 = require("./errors");
const help_1 = require("./help");
const Pkg_1 = require("./pkg/Pkg");
const install_via_symlink_1 = require("./pkg/install-via-symlink");
const install_via_localpath_1 = require("./pkg/install-via-localpath");
const symlink_1 = require("./pkg/symlink");
const version_bump_1 = require("./pkg/version-bump");
const changed_1 = require("./pkg/changed");
const diff_1 = require("./pkg/diff");
const add_1 = require("./pkg/add");
const remove_1 = require("./pkg/remove");
const check_1 = require("./pkg/check");
const publish_1 = require("./pkg/publish");
const exec_1 = require("./pkg/exec");
const list_1 = require("./pkg/list");
const dep_file_rm_1 = require("./pkg/dep-file-rm");
function handleCmd(monoRepo, subjectPkgs, args, cwd, callerCmd) {
    return __awaiter(this, void 0, void 0, function* () {
        let { npmClient } = monoRepo;
        let alreadyInstalledRoot = callerCmd === 'install' || callerCmd === 'ci';
        let forceCi = callerCmd === 'ci';
        let cmd = args.shift() || '';
        // process command aliases
        if (cmd === 'install') {
            if (arg_parse_1.peakPositionalArg(args)) {
                cmd = 'add';
            }
        }
        else if (cmd === 'uninstall') {
            if (arg_parse_1.peakPositionalArg(args)) {
                cmd = 'remove';
            }
        }
        else if (cmd === 'ci') {
            cmd = 'install';
            forceCi = true;
        }
        let cmdFuncs = {
            install() {
                check_1.ensureMonoRepoHealth(monoRepo);
                let doCopy = arg_parse_1.extractNamedFlag(args, 'copy-pkgs', false);
                let installFunc = doCopy ? install_via_localpath_1.installPkgsViaLocalPath : install_via_symlink_1.installPkgsViaSymlink;
                return installFunc(subjectPkgs, monoRepo, !alreadyInstalledRoot, forceCi, args);
            },
            link() {
                check_1.ensureMonoRepoHealth(monoRepo);
                return symlink_1.writeNeededSymlinksForPkgs(subjectPkgs, monoRepo.innerPkgsByName);
            },
            add: () => __awaiter(this, void 0, void 0, function* () {
                check_1.ensureMonoRepoHealth(monoRepo);
                subjectPkgs = scopePkgsToDir(subjectPkgs, cwd);
                let pkgAddArgs = arg_parse_1.extractPositionalArgs(args);
                let pkgAddConfigs = yield npmClient.queryAddConfig(args.slice(), monoRepo.rootDir);
                return add_1.addDepsToPkgs(monoRepo, subjectPkgs, pkgAddArgs, args, pkgAddConfigs);
            }),
            remove() {
                check_1.ensureMonoRepoHealth(monoRepo);
                subjectPkgs = scopePkgsToDir(subjectPkgs, cwd);
                let pkgRemoveArgs = arg_parse_1.extractPositionalArgs(args);
                return remove_1.removeDepsFromPkgs(monoRepo, subjectPkgs, pkgRemoveArgs, args);
            },
            check() {
                check_1.ensureMonoRepoHealth(monoRepo);
            },
            clean() {
                return dep_file_rm_1.removeAllPkgDepFiles(monoRepo.rootPkg, subjectPkgs);
            },
            version: () => __awaiter(this, void 0, void 0, function* () {
                // ensureMonoRepoHealth ?
                let versionConfig = yield npmClient.queryVersionConfig(args, monoRepo.rootDir);
                let skipPrompt = arg_parse_1.extractNamedFlag(args, 'yes');
                let forceAllPkgs = arg_parse_1.extractNamedFlag(args, 'all-pkgs', false); // TODO: keep this flag?
                if (skipPrompt) {
                    let prep = yield version_bump_1.prepareVersionBump(monoRepo, subjectPkgs, versionConfig, forceAllPkgs);
                    if (prep) {
                        return prep.execute();
                    }
                }
                else {
                    return version_bump_1.bumpVersionsWithPrompt(monoRepo, subjectPkgs, versionConfig, forceAllPkgs);
                }
            }),
            publish: () => __awaiter(this, void 0, void 0, function* () {
                let skipPrompt = arg_parse_1.extractNamedFlag(args, 'yes');
                if (skipPrompt) {
                    let prep = yield publish_1.preparePublish(monoRepo, subjectPkgs, args);
                    return prep.execute();
                }
                else {
                    return publish_1.publishPkgsWithPrompt(monoRepo, subjectPkgs, args);
                }
            }),
            list() {
                list_1.listPkgs(subjectPkgs);
            },
            changed() {
                let versionish = arg_parse_1.extractPositionalArg(args) || '';
                return changed_1.changedPkgsSincePoint(monoRepo, subjectPkgs, versionish, args).then((pkgs) => {
                    list_1.listPkgs(pkgs);
                });
            },
            diff() {
                let versionish = arg_parse_1.extractPositionalArg(args) || '';
                return diff_1.runDiff(monoRepo, subjectPkgs, versionish, args);
            },
            exec() {
                let isParallel = arg_parse_1.extractNamedFlag(args, 'parallel', true);
                return exec_1.execInPkgs(monoRepo, subjectPkgs, isParallel, args);
            },
            run() {
                let isParallel = arg_parse_1.extractNamedFlag(args, 'parallel', true);
                return exec_1.runScriptInPkgs(monoRepo, subjectPkgs, isParallel, args);
            }
        };
        let cmdFunc = cmdFuncs[cmd];
        if (cmdFunc) {
            if (arg_parse_1.argsAreHelp(args)) {
                return help_1.showHelp(cmd);
            }
            else {
                return cmdFunc();
            }
        }
        else {
            throw new errors_1.CmdNotFoundError(cmd);
        }
    });
}
exports.handleCmd = handleCmd;
function scopePkgsToDir(pkgs, dir) {
    let pkgsByDir = Pkg_1.hashPkgsByDir(pkgs);
    do {
        if (pkgsByDir[dir]) { // within a pkg's dir
            return [pkgsByDir[dir]]; // return single package
        }
        dir = path_1.dirname(dir);
    } while (!path_2.pathIsRoot(dir));
    return pkgs; // not within a pkg's dir. return all pkgs
}
