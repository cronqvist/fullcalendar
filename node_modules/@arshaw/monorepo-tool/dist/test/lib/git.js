"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const mkdirp = require("mkdirp");
const rimraf = require("rimraf");
const tmp = require("tmp");
const exec_1 = require("./exec");
function buildGitRepo(dir, config = {}) {
    let tmpDir = config.tmpDir;
    if (tmpDir) {
        if (!path_1.isAbsolute(tmpDir)) {
            tmpDir = path_1.join(process.cwd(), tmpDir);
        }
        mkdirp.sync(tmpDir);
    }
    let tmpPaths = _buildGitRepo(dir, config.submodules, tmpDir);
    function cleanup() {
        for (let tmpPath of tmpPaths) {
            rimraf.sync(tmpPath);
        }
    }
    return {
        cleanup,
        delete() {
            rimraf.sync(dir);
            cleanup();
        }
    };
}
exports.buildGitRepo = buildGitRepo;
function _buildGitRepo(dir, submodulesInput, tmpDir) {
    let submoduleStructs = {};
    let tmpPaths = [];
    if (Array.isArray(submodulesInput)) {
        for (let submodulePath of submodulesInput) {
            submoduleStructs[submodulePath] = {};
        }
    }
    else if (typeof submodulesInput === 'object' && submodulesInput) {
        submoduleStructs = submodulesInput;
    }
    exec_1.exec('git init', dir);
    for (let submodulePath in submoduleStructs) {
        let tmpPath = tmp.tmpNameSync({ dir: tmpDir });
        fs_1.renameSync(path_1.join(dir, submodulePath), tmpPath);
        let subTmpPaths = _buildGitRepo(tmpPath, submoduleStructs[submodulePath], tmpDir);
        tmpPaths.push(tmpPath, ...subTmpPaths);
        exec_1.exec(['git', 'submodule', 'add', '--quiet', tmpPath, submodulePath], dir);
    }
    exec_1.exec('git add *', dir);
    exec_1.exec('git commit -m "initial commit"', dir);
    if (Object.keys(submoduleStructs).length) {
        exec_1.exec('git submodule update --init --recursive --quiet', dir);
    }
    return tmpPaths;
}
function isGitTreeDirty(dir) {
    let { success, output } = exec_1.exec('git status --porcelain --untracked-files=no', dir);
    return !success || Boolean(output.trim());
}
exports.isGitTreeDirty = isGitTreeDirty;
