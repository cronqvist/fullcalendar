"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const exec_1 = require("./lib/exec");
const proj_1 = require("./lib/proj");
const npm_1 = require("./lib/npm");
const git_1 = require("./lib/git");
const errors_1 = require("../src/errors");
// TODO: symlink clearing
describe('install', () => {
    it('installs external and inner packages', () => {
        let proj = proj_1.buildProj({
            'monorepo.json': { packages: ['packages/*'] },
            'package.json': { dependencies: {
                    moment: '*'
                } },
            'packages/': {
                'core/': {
                    'package.json': { name: 'core', dependencies: {
                            moment: '*'
                        } }
                },
                'plug/': {
                    'package.json': { name: 'plug', dependencies: {
                            core: '*'
                        } }
                }
            }
        });
        let { success } = exec_1.bin(['install'], proj.path);
        expect(success).toBe(true);
        expect(npm_1.queryInstalled(proj.path)).toEqual({
            '.': {
                moment: true
            },
            'packages/core': {
                moment: true
            },
            'packages/plug': {
                core: '../core'
            }
        });
    });
    it('can\'t let root reference inner packages', () => {
        let proj = proj_1.buildProj({
            'monorepo.json': {
                'packages': ['packages/*']
            },
            'package.json': {
                dependencies: {
                    moment: '*',
                    core: '*'
                }
            },
            'packages/': {
                'core/': {
                    'package.json': {
                        name: 'core',
                        dependencies: {
                            moment: '*'
                        }
                    }
                },
                'plug/': {
                    'package.json': {
                        name: 'plug',
                        dependencies: {
                            'core': '*'
                        }
                    }
                }
            }
        });
        let { success, output } = exec_1.bin(['install'], proj.path);
        expect(success).toBe(false);
        expect(output).toContain(new errors_1.RootInnerRefError('dependencies', 'core').message);
    });
    it('can\'t let inner packages reference other inner packages with no version number', () => {
        let proj = proj_1.buildProj({
            'monorepo.json': {
                'packages': ['packages/*']
            },
            'packages/': {
                'core/': {
                    'package.json': { name: 'core' }
                },
                'plug/': {
                    'package.json': { name: 'plug', dependencies: {
                            core: '^2.0.0'
                        } }
                }
            }
        });
        let { success, output } = exec_1.bin(['install'], proj.path);
        expect(success).toBe(false);
        expect(output).toContain(new errors_1.InnerInnerRefError('plug', 'core').message);
    });
    it('can\'t let inner packages reference other inner packages with incompatible version number', () => {
        let proj = proj_1.buildProj({
            'monorepo.json': { 'packages': ['packages/*'] },
            'packages/': {
                'core/': {
                    'package.json': { name: 'core', version: '1.0.0' }
                },
                'plug/': {
                    'package.json': { name: 'plug', dependencies: {
                            core: '^2.0.0'
                        } }
                }
            }
        });
        let { success, output } = exec_1.bin(['install'], proj.path);
        expect(success).toBe(false);
        expect(output).toContain(new errors_1.InnerInnerRefError('plug', 'core', '^2.0.0', '1.0.0').message);
    });
    it('can\'t have multi inner packages with same name', () => {
        let proj = proj_1.buildProj({
            'monorepo.json': {
                'packages': ['packages/*']
            },
            'packages/': {
                'core/': {
                    'package.json': { name: 'core' }
                },
                'plug/': {
                    'package.json': { name: 'core' }
                }
            }
        });
        let { success, output } = exec_1.bin(['install'], proj.path);
        expect(success).toBe(false);
        expect(output).toContain(new errors_1.PkgNameCollisionError('core').message);
    });
    // installing with --copy-pkgs is broken!
    xit('can install via copying files', () => {
        let proj = proj_1.buildProj({
            'monorepo.json': { packages: ['packages/*'] },
            'package.json': { dependencies: {} },
            'packages/': {
                'core/': {
                    'package.json': { name: 'core' },
                    'file.js': 'alert("hi")'
                },
                'plug/': {
                    'package.json': { name: 'plug', dependencies: {
                            core: '*'
                        } }
                }
            }
        });
        let { success } = exec_1.bin(['install', '--copy-pkgs'], proj.path, true, true, true);
        expect(success).toBe(true);
        let pkgLstat;
        try {
            pkgLstat = fs_1.lstatSync(path_1.join(proj.path, 'packages/plug/node_modules/core'));
        }
        catch (error) { }
        expect(pkgLstat && pkgLstat.isDirectory() && !pkgLstat.isSymbolicLink()).toBe(true);
        let fileLstat;
        try {
            fileLstat = fs_1.lstatSync(path_1.join(proj.path, 'packages/plug/node_modules/core/file.js'));
        }
        catch (error) { }
        expect(fileLstat && fileLstat.isFile()).toBe(true);
        expect(git_1.isGitTreeDirty(proj.path)).toBe(false);
    });
});
